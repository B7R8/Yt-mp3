import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import fs from 'fs';
import path from 'path';
import { MediaService } from '../src/services/mediaService';
import { processAudio, downloadAudio, getJobStatus } from '../src/controllers/processAudio';

// Mock dependencies
jest.mock('../src/config/database', () => ({
  query: jest.fn()
}));

jest.mock('../src/config/logger', () => ({
  info: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  debug: jest.fn()
}));

// Mock uuid
jest.mock('uuid', () => ({
  v4: jest.fn(() => 'test-uuid-123')
}));

// Mock axios
jest.mock('axios', () => jest.fn());

// Mock child_process
jest.mock('child_process', () => ({
  spawn: jest.fn()
}));

// Mock fs
jest.mock('fs', () => ({
  existsSync: jest.fn(),
  createWriteStream: jest.fn(),
  createReadStream: jest.fn(),
  statSync: jest.fn(),
  unlinkSync: jest.fn(),
  renameSync: jest.fn(),
  mkdirSync: jest.fn()
}));

describe('MediaService', () => {
  let mediaService: MediaService;
  let mockQuery: jest.MockedFunction<any>;
  let mockAxios: jest.MockedFunction<any>;

  beforeEach(() => {
    jest.clearAllMocks();
    mediaService = new MediaService();
    
    // Get the mocked functions
    const { query } = require('../src/config/database');
    mockQuery = query;
    mockAxios = require('axios');
    
    // Setup default mocks
    (fs.existsSync as jest.Mock).mockReturnValue(true);
    (fs.statSync as jest.Mock).mockReturnValue({ size: 1024 });
    mockQuery.mockResolvedValue({ rows: [{ id: 'test-uuid-123' }] });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createJob', () => {
    it('should create a job with valid parameters', async () => {
      const request = {
        sourceUrl: 'https://example.com/audio.mp3',
        action: 'trim' as const,
        trim: { start: 10, duration: 30 },
        bitrate: 128 as const,
        expireMinutes: 20
      };

      mockQuery.mockResolvedValue({
        rows: [{
          id: 'test-uuid-123',
          source_url: request.sourceUrl,
          status: 'pending',
          action: request.action,
          bitrate: request.bitrate,
          trim_start: request.trim.start,
          trim_duration: request.trim.duration,
          download_token: 'test-token',
          expires_at: new Date()
        }]
      });

      const result = await mediaService.createJob(request);

      expect(result.id).toBe('test-uuid-123');
      expect(result.source_url).toBe(request.sourceUrl);
      expect(result.action).toBe(request.action);
      expect(mockQuery).toHaveBeenCalledWith(
        expect.stringContaining('INSERT INTO jobs'),
        expect.arrayContaining([
          'test-uuid-123',
          request.sourceUrl,
          'pending',
          request.action,
          request.bitrate,
          request.trim.start,
          request.trim.duration,
          'test-uuid-123', // download_token is generated by uuid
          expect.any(Date)
        ])
      );
    });

    it('should throw error for invalid bitrate', async () => {
      const request = {
        sourceUrl: 'https://example.com/audio.mp3',
        action: 'reencode' as const,
        bitrate: 999 as any
      };

      await expect(mediaService.createJob(request)).rejects.toThrow('Invalid bitrate');
    });

    it('should accept 64K bitrate', async () => {
      const request = {
        sourceUrl: 'https://example.com/audio.mp3',
        action: 'reencode' as const,
        bitrate: 64 as const
      };

      mockQuery.mockResolvedValue({
        rows: [{
          id: 'test-uuid-123',
          source_url: request.sourceUrl,
          status: 'pending',
          action: request.action,
          bitrate: request.bitrate,
          download_token: 'test-token',
          expires_at: new Date()
        }]
      });

      const result = await mediaService.createJob(request);
      expect(result.bitrate).toBe(64);
    });

    it('should throw error for invalid trim parameters', async () => {
      const request = {
        sourceUrl: 'https://example.com/audio.mp3',
        action: 'trim' as const,
        trim: { start: -1, duration: 30 }
      };

      await expect(mediaService.createJob(request)).rejects.toThrow('Invalid trim parameters');
    });
  });

  describe('downloadFile', () => {
    it('should download file successfully', async () => {
      const jobId = 'test-job-123';
      const sourceUrl = 'https://example.com/audio.mp3';
      const mockResponse = {
        data: {
          pipe: jest.fn(),
          on: jest.fn()
        },
        headers: {
          'content-type': 'audio/mpeg',
          'content-length': '1024'
        }
      };

      mockAxios.mockResolvedValue(mockResponse);
      (fs.createWriteStream as jest.Mock).mockReturnValue({
        on: jest.fn((event: string, callback: () => void) => {
          if (event === 'finish') callback();
        })
      });

      const result = await mediaService.downloadFile(jobId, sourceUrl);

      expect(result).toContain(jobId);
      expect(mockAxios).toHaveBeenCalledWith({
        method: 'GET',
        url: sourceUrl,
        responseType: 'stream',
        timeout: 300000,
        maxRedirects: 5,
        headers: {
          'User-Agent': expect.any(String)
        }
      });
    });

    it('should throw error for invalid content type', async () => {
      const jobId = 'test-job-123';
      const sourceUrl = 'https://example.com/audio.mp3';
      const mockResponse = {
        data: { pipe: jest.fn(), on: jest.fn() },
        headers: { 'content-type': 'text/html' }
      };

      mockAxios.mockResolvedValue(mockResponse);

      await expect(mediaService.downloadFile(jobId, sourceUrl)).rejects.toThrow('Invalid content type');
    });

    it('should throw error for file too large', async () => {
      const jobId = 'test-job-123';
      const sourceUrl = 'https://example.com/audio.mp3';
      const mockResponse = {
        data: { pipe: jest.fn(), on: jest.fn() },
        headers: { 'content-length': '200000000' } // 200MB
      };

      mockAxios.mockResolvedValue(mockResponse);

      await expect(mediaService.downloadFile(jobId, sourceUrl)).rejects.toThrow('File too large');
    });
  });

  describe('processAudio', () => {
    it('should process audio with trim action', async () => {
      const jobId = 'test-job-123';
      const inputPath = '/tmp/test.mp3';
      const jobData = {
        id: jobId,
        action: 'trim',
        bitrate: 128,
        trim_start: 10,
        trim_duration: 30,
        source_url: 'https://example.com/audio.mp3',
        status: 'processing',
        created_at: new Date(),
        expires_at: new Date()
      } as any;

      const mockProcess = {
        stderr: { on: jest.fn() },
        on: jest.fn((event: string, callback: (code: number) => void) => {
          if (event === 'close') callback(0);
        })
      };

      const { spawn } = require('child_process');
      spawn.mockReturnValue(mockProcess);
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 512 });

      const result = await mediaService.processAudio(jobId, inputPath, jobData);

      expect(result).toContain('processed');
      expect(spawn).toHaveBeenCalledWith('ffmpeg', expect.arrayContaining([
        '-i', inputPath,
        '-ss', '10',
        '-t', '30',
        '-b:a', '128k',
        '-c:a', 'libmp3lame',
        '-y', expect.stringContaining('processed')
      ]));
    });

    it('should process audio with reencode action', async () => {
      const jobId = 'test-job-123';
      const inputPath = '/tmp/test.mp3';
      const jobData = {
        id: jobId,
        action: 'reencode',
        bitrate: 256,
        source_url: 'https://example.com/audio.mp3',
        status: 'processing',
        created_at: new Date(),
        expires_at: new Date()
      } as any;

      const mockProcess = {
        stderr: { on: jest.fn() },
        on: jest.fn((event: string, callback: (code: number) => void) => {
          if (event === 'close') callback(0);
        })
      };

      const { spawn } = require('child_process');
      spawn.mockReturnValue(mockProcess);
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 512 });

      const result = await mediaService.processAudio(jobId, inputPath, jobData);

      expect(result).toContain('processed');
      expect(spawn).toHaveBeenCalledWith('ffmpeg', expect.arrayContaining([
        '-i', inputPath,
        '-b:a', '256k',
        '-c:a', 'libmp3lame',
        '-y', expect.stringContaining('processed')
      ]));
    });

    it('should handle ffmpeg failure', async () => {
      const jobId = 'test-job-123';
      const inputPath = '/tmp/test.mp3';
      const jobData = {
        id: jobId,
        action: 'none',
        source_url: 'https://example.com/audio.mp3',
        status: 'processing',
        created_at: new Date(),
        expires_at: new Date()
      } as any;

      const mockProcess = {
        stderr: { on: jest.fn() },
        on: jest.fn((event: string, callback: (code: number) => void) => {
          if (event === 'close') callback(1); // Non-zero exit code
        })
      };

      const { spawn } = require('child_process');
      spawn.mockReturnValue(mockProcess);

      await expect(mediaService.processAudio(jobId, inputPath, jobData)).rejects.toThrow('FFmpeg failed');
    });
  });

  describe('cleanupExpiredJobs', () => {
    it('should cleanup expired jobs', async () => {
      const expiredJobs = [
        { id: 'job1', processed_path: '/tmp/job1.mp3' },
        { id: 'job2', processed_path: '/tmp/job2.mp3' }
      ];

      mockQuery.mockResolvedValueOnce({ rows: expiredJobs });
      mockQuery.mockResolvedValue({ rows: [] });

      const result = await mediaService.cleanupExpiredJobs();

      expect(result).toBe(2);
      expect(fs.unlinkSync).toHaveBeenCalledTimes(2);
      expect(mockQuery).toHaveBeenCalledWith(
        expect.stringContaining('UPDATE jobs'),
        expect.any(Array)
      );
    });
  });
});

describe('ProcessAudio Controller', () => {
  let mockReq: any;
  let mockRes: any;
  let mockQuery: jest.MockedFunction<any>;

  beforeEach(() => {
    mockReq = {
      body: {},
      params: {},
      ip: '127.0.0.1',
      protocol: 'http',
      get: jest.fn(() => 'localhost:3001')
    };

    mockRes = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis(),
      setHeader: jest.fn().mockReturnThis()
    };

    // Get the mocked query function
    const { query } = require('../src/config/database');
    mockQuery = query;

    jest.clearAllMocks();
  });

  describe('processAudio', () => {
    it('should process valid audio request', async () => {
      mockReq.body = {
        sourceUrl: 'https://example.com/audio.mp3',
        action: 'trim',
        trim: { start: 10, duration: 30 },
        bitrate: 128,
        expireMinutes: 20
      };

      mockQuery.mockResolvedValue({
        rows: [{
          id: 'test-uuid-123',
          status: 'pending',
          download_token: 'test-token'
        }]
      });

      await processAudio(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(201);
      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: {
          jobId: 'test-uuid-123',
          status: 'pending',
          downloadUrl: 'http://localhost:3001/api/download/test-token'
        }
      });
    });

    it('should reject invalid sourceUrl', async () => {
      mockReq.body = {
        sourceUrl: 'invalid-url',
        action: 'trim'
      };

      await processAudio(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.json).toHaveBeenCalledWith({
        success: false,
        message: 'Invalid sourceUrl format'
      });
    });

    it('should reject invalid action', async () => {
      mockReq.body = {
        sourceUrl: 'https://example.com/audio.mp3',
        action: 'invalid'
      };

      await processAudio(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(400);
      expect(mockRes.json).toHaveBeenCalledWith({
        success: false,
        message: 'action must be one of: trim, reencode, none'
      });
    });
  });

  describe('downloadAudio', () => {
    it('should serve valid download', async () => {
      mockReq.params = { token: 'valid-token' };

      const mockJob = {
        id: 'test-job',
        status: 'ready',
        processed_path: '/tmp/test.mp3',
        expires_at: new Date(Date.now() + 60000) // 1 minute from now
      };

      mockQuery.mockResolvedValue({ rows: [mockJob] });
      (fs.existsSync as jest.Mock).mockReturnValue(true);
      (fs.statSync as jest.Mock).mockReturnValue({ size: 1024 });
      (fs.createReadStream as jest.Mock).mockReturnValue({
        pipe: jest.fn(),
        on: jest.fn()
      });

      await downloadAudio(mockReq, mockRes);

      expect(mockRes.setHeader).toHaveBeenCalledWith('Content-Type', 'audio/mpeg');
      expect(mockRes.setHeader).toHaveBeenCalledWith('Content-Length', 1024);
    });

    it('should reject expired token', async () => {
      mockReq.params = { token: 'expired-token' };

      const mockJob = {
        id: 'test-job',
        status: 'ready',
        processed_path: '/tmp/test.mp3',
        expires_at: new Date(Date.now() - 60000) // 1 minute ago
      };

      mockQuery.mockResolvedValue({ rows: [mockJob] });

      await downloadAudio(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(410);
      expect(mockRes.json).toHaveBeenCalledWith({
        success: false,
        message: 'Download link has expired'
      });
    });

    it('should reject invalid token', async () => {
      mockReq.params = { token: 'invalid-token' };

      mockQuery.mockResolvedValue({ rows: [] });

      await downloadAudio(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(404);
      expect(mockRes.json).toHaveBeenCalledWith({
        success: false,
        message: 'Download token not found'
      });
    });
  });

  describe('getJobStatus', () => {
    it('should return job status', async () => {
      mockReq.params = { jobId: 'test-job' };

      const mockJob = {
        id: 'test-job',
        status: 'ready',
        action: 'trim',
        bitrate: 128,
        file_size: 1024,
        created_at: new Date(),
        expires_at: new Date()
      };

      mockQuery.mockResolvedValue({ rows: [mockJob] });

      await getJobStatus(mockReq, mockRes);

      expect(mockRes.json).toHaveBeenCalledWith({
        success: true,
        data: expect.objectContaining({
          id: 'test-job',
          status: 'ready',
          action: 'trim',
          bitrate: 128,
          file_size: 1024
        })
      });
    });

    it('should return 404 for non-existent job', async () => {
      mockReq.params = { jobId: 'non-existent' };

      mockQuery.mockResolvedValue({ rows: [] });

      await getJobStatus(mockReq, mockRes);

      expect(mockRes.status).toHaveBeenCalledWith(404);
      expect(mockRes.json).toHaveBeenCalledWith({
        success: false,
        message: 'Job not found'
      });
    });
  });
});